rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Users collection - users can only read/write their own profile
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow create: if isAuthenticated() && request.auth.uid == userId 
        && request.resource.data.firstName is string
        && request.resource.data.lastName is string
        && request.resource.data.companyName is string
        && request.resource.data.email is string
        && request.resource.data.email == request.auth.token.email
        && request.resource.data.createdAt is timestamp;
      allow update: if isOwner(userId)
        && request.resource.data.email == resource.data.email
        && request.resource.data.createdAt == resource.data.createdAt;
      allow delete: if false; // Prevent deletion of user profiles
    }
    
    // Projects collection - users can only access their own projects
    match /projects/{projectId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.name is string
        && request.resource.data.location is string
        && request.resource.data.status in ['not_started', 'started']
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      allow update: if isAuthenticated() 
        && resource.data.userId == request.auth.uid
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'location', 'status', 'updatedAt'])
        && request.resource.data.status in ['not_started', 'started'];
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Quotations as subcollection within projects
      match /quotations/{quotationId} {
        allow read: if isAuthenticated() && get(/databases/$(database)/documents/projects/$(projectId)).data.userId == request.auth.uid;
        allow create: if isAuthenticated()
          && get(/databases/$(database)/documents/projects/$(projectId)).data.userId == request.auth.uid
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.projectId == projectId
          && request.resource.data.quotationNumber is string
          && request.resource.data.clientName is string
          && request.resource.data.clientEmail is string
          && request.resource.data.clientAddress is string
          && request.resource.data.items is list
          && request.resource.data.subtotal is number
          && request.resource.data.taxRate is number
          && request.resource.data.taxAmount is number
          && request.resource.data.total is number
          && request.resource.data.status in ['draft', 'sent', 'accepted', 'rejected']
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp;
        allow delete: if isAuthenticated() 
          && get(/databases/$(database)/documents/projects/$(projectId)).data.userId == request.auth.uid
          && resource.data.userId == request.auth.uid;
      }
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

